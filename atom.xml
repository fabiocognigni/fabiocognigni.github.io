<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[]]></title>
  <link href="http://fabiocognigni.github.io/atom.xml" rel="self"/>
  <link href="http://fabiocognigni.github.io/"/>
  <updated>2015-06-07T19:20:39+01:00</updated>
  <id>http://fabiocognigni.github.io/</id>
  <author>
    <name><![CDATA[Fabero]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[logging]]></title>
    <link href="http://fabiocognigni.github.io/blog/2014/06/07/logging/"/>
    <updated>2014-06-07T12:49:07+01:00</updated>
    <id>http://fabiocognigni.github.io/blog/2014/06/07/logging</id>
    <content type="html"><![CDATA[<p>Logs are one of the few ways to observe how your system is behaving at runtime and an invaluable help to troubleshoot issues so you better want to organize them properly.</p>

<p>Having too chatty logs means having lots of visibility but also struggling to find what you are really looking for (even with awesome tools like Splunk and Elastic search that have to index too much data).</p>

<p>Beyond the obvious common sense rules to choose at which logging level you should log a certain event/data, here  they are few best practices that worked really well in my experience.</p>

<!--more-->


<h3>Logging input and output data</h3>

<p>I use to log all the data coming in and all results produced at <strong>DEBUG</strong> level.</p>

<p>This makes these verbose logs normally not being produced (keeping the default at <strong>INFO</strong>) but still available by (temporarily) lowering the log level to DEBUG when you &ldquo;smell&rdquo; the system is not behaving properly.</p>

<p>This turns out to be very helpful to investigate issues since it provides you directly the input data to reproduce a production issue in a test environment.</p>

<p>For example I used this approach in a suite of REST APIs for validation and processing of orders: I am logging at <strong>DEBUG level</strong> <strong>all the API HTTP request and responses</strong> contents and also all the request/responses when this system makes any external call to other services.</p>

<p>Ah! Don&rsquo;t forget to make sure you <strong>obfuscate</strong> any <strong>sensitive data</strong> if they are present: credit cards info, passwords, etc&hellip; .</p>

<h3>Logging errors</h3>

<p>When you are handling an error in your code always make sure:</p>

<ul>
<li>log it at <strong>ERROR</strong> level;</li>
<li>log the complete stack trace of the error;</li>
<li>log any data in scope in that point of execution: this will be an incredible help to be able to reproduce the issue.</li>
</ul>


<h3>Changing log level dynamically</h3>

<p>Logging libraries like Logback (and Log4J also) lets you change log level at runtime without having to bring down and restart the application.</p>

<p>That is a very powerful feature you can use for example to turn the log level to DEBUG when a certain issue is happening in production. Also, you can do that for the all application (root logger) or just for a specific package or even for a specific class only.</p>

<p>The ways you can expose this operation can be different and depends on the type of application you are working on: just a restricted access web page can be enough or I also used to implement a specific HTTP endpoint when the application consisted of a REST service.</p>

<h3>Use conventions on the format</h3>

<p>If you use conventions on how you log domain specific data and errors it will be much easier to retrieve them (both for a human and for automated indexing systems).</p>

<p>For example if I&rsquo;m logging the responses for a suite of REST APIs I better use the same format for all the endpoints where I&rsquo;m doing that: for example something like: &ldquo;Response &rdquo; &ndash; endpoint name &ndash; http status code &ndash; body .</p>

<h3>Make a distinction between logs and metrics</h3>

<p>Leave out from log files what actually represents more <strong>metrics</strong> and/or <strong>analytics</strong> data that should be handled using more powerful tools (for example <strong>StatsD/Graphite</strong>) to aggregate and visualize them &ndash; talking about this would require another post.</p>

<p>Examples of this data are hit counters, error counters, execution times, order amounts, &hellip; .</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Q&A with Martin Odersky at HBC Digital]]></title>
    <link href="http://fabiocognigni.github.io/blog/2014/05/21/qa-martin-odersky/"/>
    <updated>2014-05-21T15:15:06+01:00</updated>
    <id>http://fabiocognigni.github.io/blog/2014/05/21/qa-martin-odersky</id>
    <content type="html"><![CDATA[<p>Big day here at <a href="https://twitter.com/hbcdigital">HBC Digital</a>: we hosted a Q&amp;A session with Martin Odersky at our offices in NYC.</p>

<p>When you have only one hour you have to choose really well the questions to ask among the hundreds you would have.
An important thing to keep in mind is that you are not talking with another web developer but with a &ldquo;compiler guy&rdquo; (as he defined himself). Indeed as you probably know already he wrote the compilers for modula 2, modula 3 &hellip; up to the javac Java compiler before writing Scala.
More in general it is quite impressive how he was able to apply a solid academic analysis approach to real industrial problems.</p>

<p>I think we did a pretty good job in using that limited amount of time driving the discussion on &ldquo;hot&rdquo; topics like coding philosophies, functional and object-oriented programming coexistence, comparisons with other emerging languages, Java 8 and performances.</p>

<p>Personally I didn&rsquo;t resist the temptation to use this occasion in the most constructive way: not celebrating things I like in <strong>Scala</strong> but pointing out perplexities and limits around it.</p>

<p>Here a summary of the conversation.</p>

<!--more-->


<h3>Functional and OO programming: do they make sense together?</h3>

<p>The first question was about my perplexities on the coexistence between <strong>functional</strong> and <strong>object-oriented</strong> programming. On one side functions and <strong>immutability</strong> drives you on the correct direction of keeping less state as possible and avoid side effects, on the other a construct like an object that implicitly, silently and constantly brings you to tend recreating the same issues. His answer still didn&rsquo;t convince me 100% but it makes sense: the object constructs help you organize your software in modules (but is this so much different from a namespace of pure functions?) to better handle the complexity of <strong>large systems</strong>.</p>

<h3>Scala performances</h3>

<p>My second question was around the well-know pain point of Scala: <strong>performances</strong>! I asked what exactly are the technical reasons that make the Scala compiler not that performant and I also asked for tips (if any!) around writing Scala functional code able to perform well at runtime.
His answer for the compiler performances was an incredibly interesting trip under the hood: cool Scala features like <strong>type inference</strong>, <strong>implicits</strong>, <strong>closures</strong> are objectively and inevitably expensive for the compiler that needs to resolve to the appropriate type (or value in the case of closures) in scope. He also pointed out that <strong>compiler</strong> performances have been already improved a lot recently and this optimization is still a big priority including incremental compilation. Regarding runtime performances some tips are again the same you should have been using since you were a Java programmer: e.g. use arrays and primitive types when possible &ndash; <strong>boxing</strong>/<strong>unboxing</strong> are not cheap operations. The other tips are more Scala/functional specific: use always <strong>tail recursion</strong> when possible (and help the compiler with @tailrec annotation) and take advantage from the fact that in a world of functions you can do lot of caching.</p>

<h3>Scala (not so simple) type system</h3>

<p>Another interesting and prickly question was around the fact that Scala is supposed to simplify coding through immutability and functional support but it has aspects that makes it not that simple: first of all its <strong>super detailed type system</strong>. It was also mentioned the project Dotty. He admits that the Scala type system is not small but he argued that having specialized types has obvious advantages and helps even more in the direction of type safety.</p>

<h3>Scala compared with other functional languages</h3>

<p>Dr. Odersky was then inquired regarding comparison with languages like <strong>Clojure</strong>: in here he mentioned again the importance of having object-oriented approach to have an easier modularization and have a <strong>static typing</strong> to have the compiler doing type checking and introduce as less errors as possible at runtime.</p>

<h3>Coding styles</h3>

<p>I liked also the discussion around the fact that currently it&rsquo;s hard to find in all the Scala code that you can read around a prevalent <strong>style of coding</strong>. This might be due to two factors in his opinion (totally agreed): the most obvious that is still a &ldquo;young&rdquo; language that looks really intriguing but it also take a while to be mastered. The second factor is that it leaves the programmer a broad horizon of choices given its mixed nature object-oriented/functional.</p>

<h3>Scala and Java 8</h3>

<p>The last point I want to report is his opinion about the fact that Java is finally moving in the direction Scala took long time ago, mainly for its support of <strong>lambda expressions</strong> and how the paths of Java and Scala will proceed in the long term. After joking on the fact that as of now almost only C++ was the language with no lambda expression other than Java, he pointed out how still Scala has a lot bigger conceptual space than lambda expressions mentioning the fact that in Scala <strong>functions</strong> have a <strong>type</strong>, Scala has <strong>implicits</strong>, multiple inheritance with mixin <strong>traits</strong>, <strong>pattern matching</strong> with <strong>case classes</strong>, etc. He also explained that according to the current roadmap a full support of Java 8 should be implemented in around one year (with Scala 2.12) even if probably Scala will maintain its own syntax for lambda expressions but overall performances will improve and their integration work Scala-Java will be much easier.</p>

<p>These were just some highlights of a very interesting discussion that was an extremely useful checkpoint of where we are in this JVM ecosystem and what are the possible lines of evolutions for the future.</p>

<p>Things like this definitely <strong>makes your day</strong>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[welcome]]></title>
    <link href="http://fabiocognigni.github.io/blog/2014/05/19/welcome/"/>
    <updated>2014-05-19T17:51:19+01:00</updated>
    <id>http://fabiocognigni.github.io/blog/2014/05/19/welcome</id>
    <content type="html"><![CDATA[<p>Why this blog?</p>

<p>Basically because if you love Open Source it means you love sharing your code but also the experiences (good and bad!) behind it, tips, lessons learned &hellip; and a blog is a great way to do so!</p>
]]></content>
  </entry>
  
</feed>
